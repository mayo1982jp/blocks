<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ブロックス</title>
    <style>
        body{font-family:-apple-system, BlinkMacMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;display:flex;justify-content:center;align-items:center;padding:10px;background-color:#f0f0f0;user-select:none; min-height: 10vh; margin: 0; box-sizing: border-box;}
        
        #mode-selection { display: flex; flex-direction: column; gap: 20px; padding: 40px; background-color: #fff; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); text-align: center; }
        #mode-selection h1 { margin: 0 0 10px 0; }
        .mode-button { font-size: 18px; padding: 15px 25px; cursor: pointer; border: 1px solid #ccc; border-radius: 8px; background-color: #007bff; color: white; transition: background-color 0.2s; }
        .mode-button:hover { background-color: #0056b3; }

        #game-container{display:none;gap:20px;align-items:flex-start; position: relative; width: 100%; max-width: 860px; padding-top: 50px; } /* padding-topを追加 */
        
        /* 新しいトップコントロールコンテナのスタイル */
        #top-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            gap: 10px;
            padding: 10px;
            box-sizing: border-box;
            z-index: 20;
            align-items: center;
            background-color: #f0f0f0; /* 背景色を調整 */
        }

        /* ホームボタンのスタイルを調整 */
        #home-button { 
            position: static; /* 絶対配置を解除 */
            font-size: 14px; 
            padding: 5px 10px; 
            cursor: pointer; 
            border-radius: 5px; 
            border: 1px solid #ccc; 
            background-color: #f8f8f8; /* 背景色を明示 */
        }

        #pieces-container{width:300px;padding:15px;background-color:#fff;border-radius:8px;box-shadow:0 4px 8px rgba(0,0,0,0.1);z-index:10;text-align:center; display: flex; flex-direction: column; }
        #pieces-container h2{text-align:center;margin-top:0;color:#333; font-size: 1.3em;}
        #piece-list{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-bottom: 15px;}
        .piece{display:grid;cursor:pointer;border:2px solid transparent}
        .piece.selected{border:2px solid #007bff;box-shadow:0 0 10px rgba(0,123,255,0.5);transform:scale(1.1);}
        
        .button-area { display: flex; gap: 10px; margin-top: auto;}
        .action-button{font-size:16px;padding:10px;width:100%;cursor:pointer;border-radius:5px;border:1px solid #ccc;background-color:#f8f8f8;}
        .action-button:hover{background-color:#e8e8e8;}
        .action-button:disabled { background-color: #eee; color: #aaa; cursor: not-allowed;}

        /* top-controls内のアクションボタンのスタイルを調整 */
        #top-controls .action-button {
            width: auto; /* width: 100%を上書き */
            font-size: 14px; /* ホームボタンと合わせる */
            padding: 5px 10px; /* ホームボタンと合わせる */
            background-color: #f8f8f8; /* 背景色を明示 */
        }

        #board-container{display:grid;grid-template-columns:repeat(20, 1fr);grid-template-rows:repeat(20, 1fr);border:2px solid #333; width: 500px; height: 500px; background-color:#fff;position:relative}
        .grid-cell{width:100%;height:100%;background-color:#ddd;border:1px solid #ccc;box-sizing:border-box; cursor: pointer;}
        .valid-move-highlight { background-color: rgba(255, 255, 0, 0.4) !important; }
        .color-blue{background-color:#0077b6}
        .color-yellow{background-color:#fecb00}
        .color-red{background-color:#c00000}
        .color-green{background-color:#00b050}
        
        #piece-preview { position: absolute; opacity: 0.8; pointer-events: none; z-index: 15; display: none; transition: all 0.1s ease-out; top: 0; left: 0; }
        #piece-preview.invalid-placement { filter: grayscale(1) brightness(1.5) sepia(1) hue-rotate(-50deg); opacity: 0.6; }
        #piece-preview .piece-cell {
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-sizing: border-box;
        }

        #rules-container { margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; }
        #rules-toggle { margin: 0; padding: 5px; font-size: 16px; cursor: pointer; border-radius: 5px; }
        #rules-toggle:hover { background-color: #f5f5f5; }
        #rules-toggle::after { content: ' ▼'; font-size: 10px; }
        .is-open #rules-toggle::after { content: ' ▲'; }
        #rules-content { display: none; text-align: left; font-size: 13px; color: #555; margin-top: 10px; }
        .is-open #rules-content { display: block; }
        #rules-content ul { padding-left: 20px; margin: 0; }
        #rules-content li { margin-bottom: 8px; }

        /* ★★★ スマートフォン用のスタイル（レスポンシブ対応） ★★★ */
        @media (max-width: 768px) {
            body { padding: 5px; }
            #game-container {
                flex-direction: column;
                align-items: center;
                padding-top: 60px; /* モバイルでのpadding-topを調整 */
            }
            #board-container {
                width: 95vw;
                height: 95vw;
                max-width: 500px;
                max-height: 500px;
                order: 2; /* ボードを下に表示 */
            }
            #pieces-container {
                width: 95vw;
                max-width: 500px;
                order: 1; /* ピース置き場を上に表示 */
            }
            #piece-list {
                gap: 5px;
                /* max-height: 150px; */ /* 削除 */
                /* overflow-y: auto; */ /* 削除 */
                /* padding: 5px; */ /* 削除 */
                /* border: 1px solid #eee; */ /* 削除 */
                border-radius: 5px;
            }
            /* 持ち駒のピースセルサイズをボードのセルサイズに合わせるため、このメディアクエリ内の設定は不要になります */
            /* .piece-cell {
                width: 12px;
                height: 12px;
            } */
        }

    </style>
</head>
<body>

    <div id="mode-selection">
        <h1>ブロックス</h1>
        <button id="solo-lvl1-btn" class="mode-button">1人で遊ぶ (レベル1)</button>
        <button id="solo-lvl2-btn" class="mode-button">1人で遊ぶ (レベル2)</button>
        <button id="multiplayer-btn" class="mode-button">4人で遊ぶ</button>
    </div>
    
    <div id="game-container">
        <div id="top-controls">
            <button id="home-button">ホームに戻る</button>
            <button id="undo-button" class="action-button">一手戻す</button>
            <button id="pass-button" class="action-button">パス</button>
        </div>
        <div id="pieces-container">
            <h2 id="player-turn"></h2>
            <div id="piece-list"></div>
            <div class="button-area">
                <button id="flip-vertical-button" class="action-button">上下反転 ⇅</button>
                <button id="flip-button" class="action-button">左右反転 ⇄</button>
                <button id="rotate-button" class="action-button">回転 ⤵</button>
            </div>
            <div id="rules-container">
                <h4 id="rules-toggle">ルール</h4>
                <div id="rules-content">
                    <ul>
                        <li><b>操作方法:</b><br>1. 好きなピースをタップして選択。<br>2. ボードの置きたいマスをタップして配置します。</li>
                        <li><b>回転:</b> 選択したピースは、画面下部の<b>「回転」ボタン</b>で回転できます。(PCでは右クリックも可)</li>
                        <li><b>配置ルール:</b><br>・最初のピースは、自分の色のスタート地点の角を必ず含めて配置します。<br>（<span style="color:#0077b6">■</span>青:左上, <span style="color:#fecb00">■</span>黄:右下, <span style="color:#c00000">■</span>赤:右上, <span style="color:#00b050">■</span>緑:左下）<br>・2手目以降は、自分の色のピースの「角」と角が接するように配置します。「辺」が接してはいけません。</li>
                        <li><b>勝利条件:</b><br>・置けるピースがなくなったら「パス」をします。全員がパスをしたらゲーム終了です。<br>・スコアは、手元に残ったブロックのマス目の数だけマイナス点となります。<br>・<b>最もスコアが高い（マイナス点が少ない）</b>プレイヤーが勝者です。<br>（全ピースを置くとボーナス+15点！）</li>
                        <li>公式の詳しいルールは<a href="https://mattel.co.jp/wp-content/uploads/2022/07/blokus.pdf" target="_blank" rel="noopener noreferrer">こちら</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <div id="board-container"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const BOARD_SIZE = 20;
            const PIECES_DATA = {'I1': [[1]],'I2': [[1, 1]],'I3': [[1, 1, 1]],'V3': [[1, 0], [1, 1]],'I4': [[1, 1, 1, 1]],'L4': [[1, 0, 0], [1, 1, 1]],'N4': [[0, 1, 1], [1, 1, 0]],'O4': [[1, 1], [1, 1]],'T4': [[1, 1, 1], [0, 1, 0]],'F5': [[0, 1, 1], [1, 1, 0], [0, 1, 0]],'I5': [[1, 1, 1, 1, 1]],'L5': [[1, 0], [1, 0], [1, 0], [1, 1]],'N5': [[0, 1], [0, 1], [1, 1], [1, 0]],'P5': [[1, 1], [1, 1], [1, 0]],'T5': [[1, 1, 1], [0, 1, 0], [0, 1, 0]],'U5': [[1, 0, 1], [1, 1, 1]],'V5': [[1, 0, 0], [1, 0, 0], [1, 1, 1]],'W5': [[1, 0, 0], [1, 1, 0], [0, 1, 1]],'X5': [[0, 1, 0], [1, 1, 1], [0, 1, 0]],'Y5': [[0, 1], [1, 1], [0, 1], [0, 1]],'Z5': [[1, 1, 0], [0, 1, 0], [0, 1, 1]]};
            const PLAYER_ORDER = ['blue', 'yellow', 'red', 'green'];
            const PLAYER_NAMES = { blue: 'Player 1 (Blue)', yellow: 'Player 2 (Yellow)', red: 'Player 3 (Red)', green: 'Player 4 (Green)'};
            
            let gameMode = null;
            let aiLevel = 0;
            const AI_PLAYERS = ['yellow', 'red', 'green'];
            let history = []; 

            let currentPlayerIndex, boardState, isFirstTurn, passedPlayers, allPlayerPieces;

            const modeSelectionScreen = document.getElementById('mode-selection');
            const gameContainer = document.getElementById('game-container');
            const boardContainer = document.getElementById('board-container');
            const pieceListContainer = document.getElementById('piece-list');
            const playerTurnEl = document.getElementById('player-turn');
            const passButton = document.getElementById('pass-button');
            const undoButton = document.getElementById('undo-button');
            const rotateButton = document.getElementById('rotate-button');
            const flipButton = document.getElementById('flip-button'); // 左右反転ボタンの要素を取得
            const flipVerticalButton = document.getElementById('flip-vertical-button'); // 上下反転ボタンの要素を取得
            const homeButton = document.getElementById('home-button');
            const rulesContainer = document.getElementById('rules-container');
            const rulesToggle = document.getElementById('rules-toggle');

            let selectedPieceData = null;
            let pieceAnchor = {x: 0, y: 0};
            let piecePreviewContainer = null;
            let cellWidth = 0, cellHeight = 0;
            
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

            let lastMouseX = 0; // マウスの最新のX座標を保持
            let lastMouseY = 0; // マウスの最新のY座標を保持
            let previewAnimationFrame = null; // アニメーションフレーム管理

            // グローバルなマウス移動リスナー
            if (!isTouchDevice) {
                document.addEventListener('mousemove', (e) => {
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    // スムーズな動きのためrequestAnimationFrameを使用
                    if (previewAnimationFrame) {
                        cancelAnimationFrame(previewAnimationFrame);
                    }
                    previewAnimationFrame = requestAnimationFrame(() => {
                        handleGlobalMouseMove(e);
                    });
                });
                
                // マウスがボードから離れた時の処理
                boardContainer.addEventListener('mouseleave', () => {
                    if (piecePreviewContainer) {
                        piecePreviewContainer.style.display = 'none';
                    }
                });
                
                // マウスがボードに入った時の処理
                boardContainer.addEventListener('mouseenter', () => {
                    if (selectedPieceData && piecePreviewContainer) {
                        piecePreviewContainer.style.display = 'grid';
                    }
                });
            }

            document.getElementById('solo-lvl1-btn').addEventListener('click', () => startGame('solo', 1));
            document.getElementById('solo-lvl2-btn').addEventListener('click', () => startGame('solo', 2));
            document.getElementById('multiplayer-btn').addEventListener('click', () => startGame('multiplayer', 0));
            homeButton.addEventListener('click', () => location.reload());

            function startGame(mode, level = 0) {
                gameMode = mode;
                aiLevel = level;
                if (gameMode === 'solo') { PLAYER_NAMES.yellow = `AI L${level} (黄)`; PLAYER_NAMES.red = `AI L${level} (赤)`; PLAYER_NAMES.green = `AI L${level} (緑)`;}
                modeSelectionScreen.style.display = 'none';
                gameContainer.style.display = 'flex';
                setTimeout(initGame, 0);
            }

            function initGame() {
                currentPlayerIndex = 0;
                boardState = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(null));
                isFirstTurn = { blue: true, yellow: true, red: true, green: true };
                passedPlayers = { blue: false, yellow: false, red: false, green: false };
                allPlayerPieces = {};
                history = [];
                undoButton.disabled = true;

                boardContainer.innerHTML = '';
                pieceListContainer.innerHTML = '';
                createBoard();
                
                piecePreviewContainer = document.createElement('div');
                piecePreviewContainer.id = 'piece-preview';
                boardContainer.appendChild(piecePreviewContainer);

                cellWidth = boardContainer.offsetWidth / BOARD_SIZE;
                cellHeight = boardContainer.offsetHeight / BOARD_SIZE;

                PLAYER_ORDER.forEach(color => {
                    allPlayerPieces[color] = {};
                    for (const id in PIECES_DATA) {
                        const pieceData = { id, shape: PIECES_DATA[id], color, used: false };
                        const pieceEl = createPieceElement(pieceData);
                        allPlayerPieces[color][id] = { ...pieceData, element: pieceEl };
                        pieceListContainer.appendChild(pieceEl);
                    }
                });
                rulesToggle.addEventListener('click', () => rulesContainer.classList.toggle('is-open'));
                passButton.addEventListener('click', onPass);
                undoButton.addEventListener('click', onUndo);
                rotateButton.addEventListener('click', onRotate);
                flipButton.addEventListener('click', onFlip); // 左右反転ボタンのイベントリスナーを追加
                flipVerticalButton.addEventListener('click', onFlipVertical); // 上下反転ボタンのイベントリスナーを追加
                startTurn();
            }

            function renderFromState() {
                for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) { const cell = document.querySelector(`.grid-cell[data-x='${x}'][data-y='${y}']`); const color = boardState[y][x]; if (color) { cell.className = `grid-cell placed color-${color}`; } else { cell.className = 'grid-cell'; } }
                PLAYER_ORDER.forEach(color => { for(const id in allPlayerPieces[color]) { const piece = allPlayerPieces[color][id]; piece.element.style.display = piece.used ? 'none' : 'grid'; redrawPiece(piece.element, piece.shape, color); } });
                startTurn();
            }

            function saveState() { const state = { boardState: JSON.parse(JSON.stringify(boardState)), allPlayerPieces: JSON.parse(JSON.stringify(allPlayerPieces, (k, v) => k === 'element' ? undefined : v)), isFirstTurn: {...isFirstTurn}, passedPlayers: {...passedPlayers}, currentPlayerIndex: currentPlayerIndex }; history.push(state); undoButton.disabled = false; }
            function onUndo() { if (history.length === 0) return; const lastState = history.pop(); boardState = lastState.boardState; currentPlayerIndex = lastState.currentPlayerIndex; isFirstTurn = lastState.isFirstTurn; passedPlayers = lastState.passedPlayers; PLAYER_ORDER.forEach(color => { for(const id in lastState.allPlayerPieces[color]) { allPlayerPieces[color][id].used = lastState.allPlayerPieces[color][id].used; allPlayerPieces[color][id].shape = lastState.allPlayerPieces[color][id].shape; } }); if (history.length === 0) undoButton.disabled = true; renderFromState(); }
            
            function createBoard() { 
                for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) { const cell = document.createElement('div'); cell.classList.add('grid-cell'); cell.dataset.x = i % BOARD_SIZE; cell.dataset.y = Math.floor(i / BOARD_SIZE); cell.addEventListener('click', onBoardClick); boardContainer.appendChild(cell); } 
                // 以前のboardContainerに対するマウスイベントリスナーは削除
            }
            
            function createPieceElement(pieceData) {
                const { id, shape, color } = pieceData;
                const pieceEl = document.createElement('div'); pieceEl.classList.add('piece'); pieceEl.dataset.pieceId = id; pieceEl.dataset.color = color;
                redrawPiece(pieceEl, shape, color);
                pieceEl.addEventListener('click', (e) => {
                    const currentPlayer = PLAYER_ORDER[currentPlayerIndex]; if(gameMode === 'solo' && AI_PLAYERS.includes(currentPlayer)) return;
                    document.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
                    e.currentTarget.classList.add('selected');
                    rotateButton.style.display = 'inline-block';
                    flipButton.style.display = 'inline-block'; // 左右反転ボタンを表示
                    flipVerticalButton.style.display = 'inline-block'; // 上下反転ボタンを表示
                    selectedPieceData = allPlayerPieces[color][id];
                    pieceAnchor = pieceAnchorForShape(selectedPieceData.shape);
                    updatePreviewPiece();
                    if (!isTouchDevice) {
                        // ピース選択時にプレビューを即座に更新
                        handleGlobalMouseMove({ clientX: lastMouseX, clientY: lastMouseY });
                    }
                });
                if (!isTouchDevice) {
                    pieceEl.addEventListener('contextmenu', e => { e.preventDefault(); onRotate(); });
                }
                return pieceEl;
            }

            function onRotate() {
                if (!selectedPieceData) return;
                selectedPieceData.shape = rotateMatrix(selectedPieceData.shape);
                redrawPiece(selectedPieceData.element, selectedPieceData.shape, selectedPieceData.color);
                pieceAnchor = pieceAnchorForShape(selectedPieceData.shape);
                updatePreviewPiece();
                if (!isTouchDevice) {
                    // 回転時にもプレビューを即座に更新
                    handleGlobalMouseMove({ clientX: lastMouseX, clientY: lastMouseY });
                }
            }

            // ピースを水平方向に反転させる関数
            function onFlip() {
                if (!selectedPieceData) return;
                selectedPieceData.shape = flipMatrixHorizontal(selectedPieceData.shape);
                redrawPiece(selectedPieceData.element, selectedPieceData.shape, selectedPieceData.color);
                pieceAnchor = pieceAnchorForShape(selectedPieceData.shape);
                updatePreviewPiece();
                if (!isTouchDevice) {
                    handleGlobalMouseMove({ clientX: lastMouseX, clientY: lastMouseY });
                }
            }

            // ピースを垂直方向に反転させる関数
            function onFlipVertical() {
                if (!selectedPieceData) return;
                selectedPieceData.shape = flipMatrixVertical(selectedPieceData.shape);
                redrawPiece(selectedPieceData.element, selectedPieceData.shape, selectedPieceData.color);
                pieceAnchor = pieceAnchorForShape(selectedPieceData.shape);
                updatePreviewPiece();
                if (!isTouchDevice) {
                    handleGlobalMouseMove({ clientX: lastMouseX, clientY: lastMouseY });
                }
            }
            
            function redrawPiece(targetEl, shape, color) { 
                const isPreview = targetEl.id === 'piece-preview'; 
                // 持ち駒のピースとプレビューピースのセルサイズをボードのセルサイズに合わせる
                const pieceCellSize = cellWidth; 
                targetEl.innerHTML = ''; 
                const rows = shape.length, cols = shape[0].length; 
                targetEl.style.gridTemplateRows = `repeat(${rows}, ${pieceCellSize}px)`; 
                targetEl.style.gridTemplateColumns = `repeat(${cols}, ${pieceCellSize}px)`; 
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) { 
                        const cell = document.createElement('div'); 
                        cell.classList.add('piece-cell'); 
                        if (shape[y][x] === 1) cell.classList.add(`color-${color}`); 
                        else if (!isPreview) cell.classList.add('empty'); 
                        targetEl.appendChild(cell); 
                    }
                }
            }
            function rotateMatrix(matrix) { const rows = matrix.length, cols = matrix[0].length; const newMatrix = Array.from({ length: cols }, () => Array(rows).fill(0)); for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) newMatrix[x][rows - 1 - y] = matrix[y][x]; return newMatrix; }
            
            // ピースを水平方向に反転させる関数
            function flipMatrixHorizontal(matrix) {
                return matrix.map(row => [...row].reverse());
            }

            // ピースを垂直方向に反転させる関数
            function flipMatrixVertical(matrix) {
                return [...matrix].reverse();
            }

            // グローバルなマウス移動ハンドラ
            function handleGlobalMouseMove(e) {
                if (!selectedPieceData) {
                    if (piecePreviewContainer) piecePreviewContainer.style.display = 'none';
                    return;
                }

                const boardRect = boardContainer.getBoundingClientRect();
                const mouseX = e.clientX;
                const mouseY = e.clientY;

                // マウスがボード上にあるかチェック
                const isMouseOverBoard = mouseX >= boardRect.left && mouseX < boardRect.right &&
                                         mouseY >= boardRect.top && mouseY < boardRect.bottom;

                if (isMouseOverBoard) {
                    piecePreviewContainer.style.display = 'grid';
                    // ボードの左上を基準としたマウス座標
                    const relativeMouseX = mouseX - boardRect.left;
                    const relativeMouseY = mouseY - boardRect.top;

                    const gridX = Math.floor(relativeMouseX / cellWidth);
                    const gridY = Math.floor(relativeMouseY / cellHeight);

                    const startX = gridX - pieceAnchor.x;
                    const startY = gridY - pieceAnchor.y;

                    const previewX = startX * cellWidth;
                    const previewY = startY * cellHeight;

                    // スムーズな移動のためのトランジション
                    piecePreviewContainer.style.transition = 'transform 0.05s ease-out';
                    piecePreviewContainer.style.transform = `translate(${previewX}px, ${previewY}px)`;

                    // グリッド線の位置に合わせて微調整
                    const offsetX = relativeMouseX % cellWidth;
                    const offsetY = relativeMouseY % cellHeight;
                    const snapX = offsetX < cellWidth / 2 ? previewX : previewX + cellWidth;
                    const snapY = offsetY < cellHeight / 2 ? previewY : previewY + cellHeight;

                    // 実際の配置位置を計算
                    const actualStartX = Math.round((mouseX - boardRect.left) / cellWidth) - pieceAnchor.x;
                    const actualStartY = Math.round((mouseY - boardRect.top) / cellHeight) - pieceAnchor.y;

                    const isValid = isValidPlacement(actualStartX, actualStartY, selectedPieceData);
                    piecePreviewContainer.classList.toggle('invalid-placement', !isValid);
                    
                    // 有効/無効の視覚的フィードバック
                    if (isValid) {
                        piecePreviewContainer.style.opacity = '0.8';
                        piecePreviewContainer.style.boxShadow = '0 0 8px rgba(0, 123, 255, 0.5)';
                    } else {
                        piecePreviewContainer.style.opacity = '0.6';
                        piecePreviewContainer.style.boxShadow = '0 0 8px rgba(255, 0, 0, 0.5)';
                    }
                } else {
                    // ボードの外ではプレビューを非表示
                    piecePreviewContainer.style.display = 'none';
                }
            }

            function updatePreviewPiece() { 
                if (!selectedPieceData) {
                    if (piecePreviewContainer) piecePreviewContainer.style.display = 'none';
                    return; 
                }
                redrawPiece(piecePreviewContainer, selectedPieceData.shape, selectedPieceData.color);
                
                // 現在のマウス位置で即座にプレビューを更新
                if (!isTouchDevice) {
                    const fakeEvent = { clientX: lastMouseX, clientY: lastMouseY };
                    handleGlobalMouseMove(fakeEvent);
                }
            }

            function onBoardClick(e) {
                const currentPlayer = PLAYER_ORDER[currentPlayerIndex]; if (gameMode === 'solo' && AI_PLAYERS.includes(currentPlayer)) return;
                if (!selectedPieceData) { alert('先に左のリストからピースを選択してください。'); return; }
                const clickX = parseInt(e.target.dataset.x); const clickY = parseInt(e.target.dataset.y);
                const startX = clickX - pieceAnchor.x; const startY = clickY - pieceAnchor.y;
                if (isValidPlacement(startX, startY, selectedPieceData)) {
                    saveState();
                    placePieceOnBoard(startX, startY, selectedPieceData);
                    selectedPieceData.used = true;
                    isFirstTurn[selectedPieceData.color] = false;
                    nextTurn();
                } else {
                    alert('ここには配置できません！ルールを確認してください。');
                }
            }
            function onPass() { const currentPlayer = PLAYER_ORDER[currentPlayerIndex]; if (gameMode === 'solo' && AI_PLAYERS.includes(currentPlayer)) return; if (!passedPlayers[currentPlayer]) { saveState(); passedPlayers[currentPlayer] = true; nextTurn(); } }

            function nextTurn() { if (Object.values(passedPlayers).every(p => p)) { endGame(); return; } let nextPlayerFound = false; let sanityCheck = 5; while(!nextPlayerFound && sanityCheck > 0) { currentPlayerIndex = (currentPlayerIndex + 1) % PLAYER_ORDER.length; if (!passedPlayers[PLAYER_ORDER[currentPlayerIndex]]) { nextPlayerFound = true; } sanityCheck--; } startTurn(); }
            
            function startTurn() {
                const currentPlayer = PLAYER_ORDER[currentPlayerIndex];
                playerTurnEl.innerText = PLAYER_NAMES[currentPlayer];
                
                selectedPieceData = null;
                if (piecePreviewContainer) piecePreviewContainer.style.display = 'none'; // ターン開始時にプレビューを非表示
                rotateButton.style.display = 'none';
                flipButton.style.display = 'none'; // 左右反転ボタンを非表示
                flipVerticalButton.style.display = 'none'; // 上下反転ボタンを非表示
                document.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));

                const allPieceEls = pieceListContainer.querySelectorAll('.piece');
                allPieceEls.forEach(el => { const color = el.dataset.color; const id = el.dataset.pieceId; const isUsed = allPlayerPieces[color][id].used; if (color === currentPlayer && !isUsed) { el.style.display = 'grid'; } else { el.style.display = 'none'; } });
                
                highlightValidMoves();

                if (gameMode === 'solo' && AI_PLAYERS.includes(currentPlayer)) {
                    document.querySelectorAll('.action-button').forEach(b => b.disabled = true);
                    playerTurnEl.innerText += ' (思考中...)';
                    setTimeout(executeAITurn, 500);
                } else {
                    document.querySelectorAll('.action-button').forEach(b => b.disabled = false);
                    if(history.length === 0) undoButton.disabled = true;
                }
            }

            function executeAITurn() {
                if (aiLevel === 1) executeLvl1AI();
                else if (aiLevel === 2) executeLvl2AI();
            }

            function executeLvl1AI() {
                const currentPlayer = PLAYER_ORDER[currentPlayerIndex]; let availablePieces = Object.values(allPlayerPieces[currentPlayer]).filter(p => !p.used); shuffleArray(availablePieces); let allCoordinates = []; for (let y = 0; y < BOARD_SIZE; y++) for(let x=0; x < BOARD_SIZE; x++) allCoordinates.push({x,y}); shuffleArray(allCoordinates);
                for (const piece of availablePieces) { 
                    let originalShape = JSON.parse(JSON.stringify(piece.shape)); // 元の形状を保存
                    for (let flipH = 0; flipH < 2; flipH++) { // 水平反転の有無 (0:なし, 1:あり)
                        for (let flipV = 0; flipV < 2; flipV++) { // 垂直反転の有無 (0:なし, 1:あり)
                            for (let rotation = 0; rotation < 4; rotation++) { 
                                for (const coord of allCoordinates) { 
                                    const anchor = pieceAnchorForShape(piece.shape); 
                                    const startX = coord.x - anchor.x; 
                                    const startY = coord.y - anchor.y; 
                                    if (isValidPlacement(startX, startY, piece)) { 
                                        saveState(); 
                                        placePieceOnBoard(startX, startY, piece); 
                                        piece.used = true; 
                                        isFirstTurn[piece.color] = false; 
                                        nextTurn(); 
                                        return; 
                                    } 
                                } 
                                piece.shape = rotateMatrix(piece.shape); 
                            } 
                            if (flipV === 0) piece.shape = flipMatrixVertical(piece.shape); // 1回目の垂直ループ後に垂直反転
                        }
                        if (flipH === 0) piece.shape = flipMatrixHorizontal(piece.shape); // 1回目の水平ループ後に水平反転
                    }
                    piece.shape = originalShape; // ピースの形状を元に戻す
                }
                saveState(); passedPlayers[currentPlayer] = true; nextTurn();
            }
            
            function executeLvl2AI() {
                const currentPlayer = PLAYER_ORDER[currentPlayerIndex]; const availablePieces = Object.values(allPlayerPieces[currentPlayer]).filter(p => !p.used); availablePieces.sort((a, b) => b.shape.flat().reduce((s,c)=>s+c,0) - a.shape.flat().reduce((s,c)=>s+c,0));
                for (const piece of availablePieces) { 
                    let originalShape = JSON.parse(JSON.stringify(piece.shape)); 
                    for (let flipH = 0; flipH < 2; flipH++) { // 水平反転の有無
                        for (let flipV = 0; flipV < 2; flipV++) { // 垂直反転の有無
                            for (let rotation = 0; rotation < 4; rotation++) { 
                                for (let y = 0; y < BOARD_SIZE; y++) 
                                    for (let x = 0; x < BOARD_SIZE; x++) { 
                                        const anchor = pieceAnchorForShape(piece.shape); 
                                        const startX = x - anchor.x; 
                                        const startY = y - anchor.y; 
                                        if (isValidPlacement(startX, startY, piece)) { 
                                            saveState(); 
                                            placePieceOnBoard(startX, startY, piece); 
                                            piece.used = true; 
                                            isFirstTurn[piece.color] = false; 
                                            nextTurn(); 
                                            return; 
                                        } 
                                    } 
                                piece.shape = rotateMatrix(piece.shape); 
                            } 
                            if (flipV === 0) piece.shape = flipMatrixVertical(piece.shape); 
                        }
                        if (flipH === 0) piece.shape = flipMatrixHorizontal(piece.shape); 
                    }
                    piece.shape = originalShape; 
                }
                saveState(); passedPlayers[currentPlayer] = true; nextTurn();
            }
            
            function clearHighlights() { document.querySelectorAll('.valid-move-highlight').forEach(c => c.classList.remove('valid-move-highlight')); }
            function highlightValidMoves() {
                clearHighlights();
                const currentPlayer = PLAYER_ORDER[currentPlayerIndex];
                if (gameMode === 'solo' && AI_PLAYERS.includes(currentPlayer)) return;

                if (isFirstTurn[currentPlayer]) {
                    const targetCorner = { blue: [0, 0], yellow: [19, 19], red: [0, 19], green: [19, 0] }[currentPlayer];
                    const cell = document.querySelector(`.grid-cell[data-x='${targetCorner[0]}'][data-y='${targetCorner[1]}']`);
                    if (cell) cell.classList.add('valid-move-highlight');
                    return;
                }

                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (boardState[y][x] !== null) continue;
                        let touchesCorner = false;
                        const corners = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                        for (const [dy, dx] of corners) {
                            const checkY = y + dy, checkX = x + dx;
                            if (checkY >= 0 && checkY < BOARD_SIZE && checkX >= 0 && checkX < BOARD_SIZE && boardState[checkY][checkX] === currentPlayer) {
                                touchesCorner = true;
                                break;
                            }
                        }
                        if (!touchesCorner) continue;
                        let touchesSide = false;
                        const neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        for (const [dy, dx] of neighbors) {
                            const checkY = y + dy, checkX = x + dx;
                            if (checkY >= 0 && checkY < BOARD_SIZE && checkX >= 0 && checkX < BOARD_SIZE && boardState[checkY][checkX] === currentPlayer) {
                                touchesSide = true;
                                break;
                            }
                        }
                        if (!touchesSide) {
                            const cell = document.querySelector(`.grid-cell[data-x='${x}'][data-y='${y}']`);
                            if (cell) cell.classList.add('valid-move-highlight');
                        }
                    }
                }
            }

            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }
            function pieceAnchorForShape(shape) { for (let y = 0; y < shape.length; y++) for (let x = 0; x < shape[y].length; x++) if(shape[y][x] === 1) return {x, y}; return {x:0, y:0}; }
            function isValidPlacement(startX, startY, pieceData) { if (!pieceData) return false; const { shape, color } = pieceData; for (let y = 0; y < shape.length; y++) for (let x = 0; x < shape[y].length; x++) if (shape[y][x] === 1) { const gridX = startX + x, gridY = startY + y; if (gridX < 0 || gridX >= BOARD_SIZE || gridY < 0 || gridY >= BOARD_SIZE) return false; if (boardState[gridY][gridX] !== null) return false; } if (isFirstTurn[color]) { const targetCorner = { blue: [0, 0], yellow: [19, 19], red: [0, 19], green: [19, 0] }[color]; let coversStartCorner = false; for (let y = 0; y < shape.length; y++) { for (let x = 0; x < shape[y].length; x++) if (shape[y][x] === 1 && (startX + x) === targetCorner[0] && (startY + y) === targetCorner[1]) { coversStartCorner = true; break; } if (coversStartCorner) break; } return coversStartCorner; } else { let touchesCorner = false; for (let y = 0; y < shape.length; y++) for (let x = 0; x < shape[y].length; x++) if (shape[y][x] === 1) { const gridX = startX + x, gridY = startY + y; const neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]]; for (const [dy, dx] of neighbors) { const checkY = gridY + dy, checkX = gridX + dx; if (checkY >= 0 && checkY < BOARD_SIZE && checkX >= 0 && checkX < BOARD_SIZE && boardState[checkY][checkX] === color) return false; } const corners = [[-1, -1], [-1, 1], [1, -1], [1, 1]]; for (const [dy, dx] of corners) { const checkY = gridY + dy, checkX = gridX + dx; if (checkY >= 0 && checkY < BOARD_SIZE && checkX >= 0 && checkX < BOARD_SIZE && boardState[checkY][checkX] === color) touchesCorner = true; } } return touchesCorner; } }
            function placePieceOnBoard(startX, startY, pieceData) { const { shape, color } = pieceData; for(let y = 0; y < shape.length; y++) for (let x = 0; x < shape[y].length; x++) if (shape[y][x] === 1) { const gridX = startX + x, gridY = startY + y; if (gridX < 0 || gridX >= BOARD_SIZE || gridY < 0 || gridY >= BOARD_SIZE) continue; boardState[gridY][gridX] = color; const cell = document.querySelector(`.grid-cell[data-x='${gridX}'][data-y='${gridY}']`); if (cell) cell.className = `grid-cell placed color-${color}`; } }
            function endGame() { clearHighlights(); let finalScores = {}; let resultText = "--- ゲーム終了！最終スコア ---\n\n"; PLAYER_ORDER.forEach(color => { let score = 0; const playerPieces = allPlayerPieces[color]; const hasUsedAllPieces = Object.values(playerPieces).every(p => p.used); if (hasUsedAllPieces) { score = 15; const smallestPiece = playerPieces['I1']; if (smallestPiece && smallestPiece.used) { score += 5; } } else { for(const id in playerPieces) { if (!playerPieces[id].used) { score -= playerPieces[id].shape.flat().reduce((a, b) => a + b, 0); } } } finalScores[color] = score; resultText += `${PLAYER_NAMES[color]}: ${score}点\n`; }); const winnerScore = Math.max(...Object.values(finalScores)); const winners = Object.keys(finalScores).filter(color => finalScores[color] === winnerScore); resultText += "\n勝者: " + winners.map(color => PLAYER_NAMES[color]).join(', '); alert(resultText); document.querySelectorAll('.action-button').forEach(b => b.disabled = true); playerTurnEl.innerText = 'Game Over'; }
        });
    </script>
</body>
</html>